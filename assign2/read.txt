################################################################################
################################################################################
RUNNING THE PROGRAM: python submission.py
################################################################################
################################################################################
Testing Accuracy: Simply put the shared key printed on the first line into google authenticator and compare the generated OTPs from my program to the OTPs generated by google authenticator.
################################################################################
Implementation reasoning:
Luckily there is good documentation on TOTP implementation. I first found this general outline:
	- Calculate C as the number of times TI has elapsed after T0.
	- Compute the HMAC hash H with C as the message and K as the key (the HMAC algorithm is defined in the previous section, but also most cryptographical libraries support it). K should be passed as it is, C should be passed as a raw 64-bit unsigned integer.
	- Take the least 4 significant bits of H and use it as an offset, O.
	- Take 4 bytes from H starting at O bytes MSB, discard the most significant bit and store the rest as an (unsigned) 32-bit integer, I.
	- The token is the lowest N digits of I in base 10. If the result has fewer digits than N, pad it with zeroes from the left.
I then found some great Pseudocode of the google authenticator:
function GoogleAuthenticatorCode(string secret)
      key := base32decode(secret)
      message := floor(current Unix time / 30)
      hash := HMAC-SHA1(key, message)
      offset := last nibble of hash
      truncatedHash := hash[offset..offset+3]  //4 bytes starting at the offset
      Set the first bit of truncatedHash to zero  //remove the most significant bit
      code := truncatedHash mod 1000000
      pad code with 0 until length of code is 6
      return code
I pretty much followed this outline and Pseudocode to the letter, and it worked perfectly. I was able to accomplish the entire project in just 20 lines of code!
#################################################################################
ASSUMPTIONS:
- I assume that the professor wanted just a hardcoded key to check against the google authenticator app. If he wanted us to be able to test any proper shared key, then just change line 15 to key = raw_input("enter key here").
- I assume that I only need to be able to handle real shared keys and therefore, they must be in the format google two factor uses for their keys: base32 (spaces and case do not matter in this case but length and characters do).
################################################################################
