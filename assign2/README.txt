################################################################################
################################################################################
RUNNING THE PROGRAM: python submission.py
################################################################################
################################################################################
Testing Accuracy: Simply put the shared key printed on the first line into google authenticator and compare the generated OTPs from my program to the OTPs generated by google authenticator.
################################################################################
Implementation reasoning:
Luckily there is good documentation on TOTP implementation. I found this Pseudocode:

function GoogleAuthenticatorCode(string secret)
      key := base32decode(secret)
      message := floor(current Unix time / 30)
      hash := HMAC-SHA1(key, message)
      offset := last nibble of hash
      truncatedHash := hash[offset..offset+3]  //4 bytes starting at the offset
      Set the first bit of truncatedHash to zero  //remove the most significant bit
      code := truncatedHash mod 1000000
      pad code with 0 until length of code is 6
      return code

 Each line into instructions of what I needed to do:

	- Calculate C as the number of times TI has elapsed after T0.

	- Compute the HMAC hash H with C as the message and K as the key (the HMAC algorithm is defined in the previous section, but also most cryptographical libraries support it). K should be passed as it is, C should be passed as a raw 64-bit unsigned integer.

	- Take the least 4 significant bits of H and use it as an offset, O.

	- Take 4 bytes from H starting at O bytes MSB, discard the most significant bit and store the rest as an (unsigned) 32-bit integer, I.

	- The token is the lowest N digits of I in base 10. If the result of mod 1000000 has fewer digits than N, pad it with zeroes from the left.

I pretty much followed this outline and Pseudocode to the letter, and it worked perfectly. I was able to accomplish the entire project in just 20 lines of code.

What TOTP actually does:
	TOTP is a algorithm which generates a one time password from a shared secret key to authenticate a user in a system though an authentication server. TOTP is like HOTP but subsititutes the timestamp to replace the increment counter in HOTP.
#################################################################################
ASSUMPTIONS:
- I assume that the professor wanted just a hardcoded key to check against the google authenticator app. If he wanted us to be able to test any proper shared key, then just change line 15 to key = raw_input("enter key here").
- I assume that I only need to be able to handle real shared keys and therefore, they must be in the format google two factor uses for their keys: base32 (spaces and case do not matter in this case but length and characters do).
################################################################################
SOURCES: Matthew Baker (classmate) - Talked over what binary packing was, how to implement it into the time value
github user: djui -- https://gist.github.com/djui/a945426b7f3c0bd45e3b-- What I learned: how to create the digest with binary packed time value, unpacking the correct nibble into an integer,padding w/ leading zeros.
